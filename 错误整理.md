# 错误整理

标签（空格分隔）： 错误整理

---

 使用 CAJSON 进行格式转换时，导致数据丢失的问题总结
------------
**问题详情**：在使用 `CAJSON` 对关联表查询出来的数据进行 `json` 格式转换的时候，发现有一部分数据丢失

**原因总结**：
1. 丢失的数据是查询结果集里的私有属性，例如：`["_related":"CActiveRecord":private] => 'xxxxx'`，该私有属性并没有重新赋值给添加的公有属性
2. 调用了 `CJSON` 方法，丢失的数据不属于所查询的表里的字段，或者不在 `fields` 里。
3. 粗心，把公有属性的变量名看错了

使用 `while` 循环注意避免死循环的问题总结
--------------------

**问题详情**：在实现对特定音单下音频的查找时，按照中间表—`m_sound_album_map`里的排序字段 `sort` 来对特定音单下的音频进行排序显示。`sort` 字段的值是排在这个单音后面的下一个单音的 ID，而排在首位的单音 `sort` 值为 0 。对查询出来的单音进行排序的这个过程中使用到了 `while` 循环操作。

**代码详情**：

```php
$sound_infos = MSoundAlbumMap::model()->findAll([
    'select' => 'sound_id, sort',
    'condition' => 'album_id = :album_id',
    'params' => [':album_id' => $album_id]
]);
// 需要排序的单音 ID 数组
$need_sort_sounds = [];
foreach ($sound_infos as $info) {
    $need_sort_sounds[$info['sort']] = $info['sound_id'];
}
$key_sound_id = $need_sort_sounds[0] ?: null;
// 已排好序的单音 ID 数组
$sorted_sound_ids = [];
while ($key_sound_id) {
    if ($key_sound_id) $sorted_sound_ids[] = $key_sound_id;
    $key_sound_id = $need_sort_sounds[$key_sound_id] ?? null;
}
```

这样的 `while` 操作很容易出现死循环的情况，当 `sort` 的值指向自己的时候，就会出现死循环。

**解决方法**：为了避免死循环的情况，可以先对 `$need_sort_sounds` 进行个数统计 `count()`，每循环一次后 `$count--`。并且 while 的判断里与上 `$count`。这样就能避免即使数据出错后，`sort` 指向了自己也不会出现死循环的情况了。

**解决方法代码详情**：

```php
$sound_infos = MSoundAlbumMap::model()->findAll([
    'select' => 'sound_id, sort',
    'condition' => 'album_id = :album_id',
    'params' => [':album_id' => $album_id]
]);
// 需要排序的单音 ID 数组
$need_sort_sounds = [];
foreach ($sound_infos as $info) {
    $need_sort_sounds[$info['sort']] = $info['sound_id'];
}
$key_sound_id = $need_sort_sounds[0] ?: null;
// 已排好序的单音 ID 数组
$sorted_sound_ids = [];
$count = count($need_sort_sounds);
while ($count && $key_sound_id) {
    if ($key_sound_id) $sorted_sound_ids[] = $key_sound_id;
    $key_sound_id = $need_sort_sounds[$key_sound_id] ?? null;
    $count--;
}
```

**原因总结**：会犯这种错首先是没有一个好的思维方式，使用循环首先就要想到是否会有死循环的情况，如果会有该怎么避免；第二是要仔细考虑到数据的各种可能存在的情况，不能太相信数据库里的数据正确性